This file will help you to use properly and  safely the project's Scheduler.

TRACER's Task Scheduler is not preemptive, and can conserve the order, for some particular cases, that we will detail
    here.


OBJECTIVES :

The scheduler responds to the following criteria :
    - it (and only it) is responsible for interrogating interface, only when task can be added, to avoid data loss.
    - conserve the order for some groups of tasks. For example, all tasks concerning movement must be executed in their
        order of reception;
    - Allow some particular tasks to be executed as soon as possible. For example, an emergency stop, or a modification
        in the EEPROM doesn't have to respect any order of execution, and must be processed as soon as possible.






I - Task

A task is a simple struct, containing :
    - A task_state_t(*)(void *), a function pointer, taking a void *, and returning a task_state_t;
        the void * is a pointer to the first case of the arguments
    - a void *, a pointer to the first case of the arguments (must be stored in the heap).
    - an uin8_t, the type of the task (see below)


The type of the task determines how it will be executed.
    - A task with the type 255 is executed as soon as possible.
    - A task with the type !=255 (between 0 and 254) belongs to a task queue, and musn't be executed while takss of the
        same type, received before, have not been executed.

//TODO ARGUMENTS

Tasks mainly come from interfaces. The scheduler will regularly consult interfaces, and those will add tasks
    if spaces are available.

An important thing to know, is that tasks comming from interfaces are not necessarly typed : a function in the terminal interface
(for example) may plan a future stepper movement, and a DC movement. These two tasks have different types.
The type of a task created by an interface is, as we have seen, not determined, and so, will always be 255.



II - Scheduler structure :

The scheduler is constituted of one task pool, and of some task queues.
The main difference between the two groups is that task pool is not ordered, and the task queues are not.


When a task is generated by an interface, as its type is 255, it goes directly in the task pool,
after the last task in the array.

Task pool :

    The task pool is an array of tasks. When tasks are added, they are put at the last position.
    The task pool is not ordered, in the meaning that tasks are not necessarily processed in a particular order.
    Nevertheless, their order in the array is the exact order they were added.

        Example :

        The task pool contains 6 tasks (1, 2, 3, 4, 5 and 6)

        | 1  2  3  4  5  6  _  _  _  _  _  _  |

        In the example below, the scheduler tries to process tasks 1, 2, and 3, but those are currently un-executable (
            they may require some currently unavailable space in the movement queue, for example).
            The scheduler then executes the task 4, with success.

        | 1  2  3  _  5  6  _  _  _  _  _  _  |

        In order to maintain the order of the task in the array, the scheduler will then shift tasks 5 and 6 of 1 case :

        | 1  2  3  5  6  _  _  _  _  _  _  _  |

        With this procedure, we are sure that a task at the index i in the task pool has been added before tasks > i,
            and after tasks < i.


When the scheduler receives a task with a non-255 type it enqueues it in the appropriate queue.

Task Queue :

    A task queue is (literally) a queue of task. The only thing the Scheduler can do, is processing the first task.

    This structure is ordered, this means tasks will be executed in the order they were added.


III - Execution algorithm

For executing its tasks, the scheduler process like the following :
    - if tasks can be added, parse data on interfaces -> tasks are added to the task pool.
    - Process all possible tasks in the task pool -> tasks may be added to
    - For each task queue :
        1 pop the first task;
        2 if the task can be processed, process it. If not, go to the next queue;
        3 if the queue is not empty, go to step 1.



IV - The problem of the order.

As we said before, tasks generated by interfaces are always of type 255. However, there tasks may create tasks of type
!= 255. As you now know, these tasks must be executed in the order they were added, but they are created by a
task of type 255, and tasks of type 255 are not processed in order!

As you can guess, this problem cannot be solved without implementing some security mechanisms :

0 - only type-255 tasks can generate new tasks.

1 - during its execution, a type-255 task can lock a particular queue, preventing any adding for this queue.

2 - at the beginning of its execution, a type-255 task must verify that every queue it may enqueue tasks is not locked,
    and have enough space to contain all tasks the function wants to enqueue.
    If not, the function locks all queues where it has to enqueue tasks, and fails.

3 - if a function fails, it is not deleted of the scheduler. It will be re-executed later.

4 - after an evaluation of the task pool, the scheduler unlocks all queues.



Let's illustrate it with an example :

The task pool contains 7 type-255 tasks and no space : 
    - tasks 0, 1 and 5 are native type255 tasks : they do not add tasks to any queue
    - task 4 must add another type-255 in the task pool.
    - task 2 adds two tasks, a type-0 and a type-1.
    - task 3 adds a type-1 task;
    - task 6 adds a type-0 task;
    
    We will suppose, to simplify, that interfaces never create new tasks, and that only things that will prevent
        task to execute properly are Queues states.

    SCHEDULER STATE :
    TASK_POOL | 0() 1()  2(0, 1)  3(1)  4(255)  5()  6(0)  |   ##  QUEUE_0 : 2 spaces left  ##  QUEUE_1 : 0 spaces left
        

ROUND 0 :

    First, the scheduler will process the task pool :
    - tasks 0 and 1 are executed. 
    - task 2 must add a type-1 task, but no spaces are left in the queue 1.
        -> queues 0 and 1 are locked, and task 2 doesn't complete.
    - task 3 doesn't complete, because it must add a type-1 task, and queue 1 is locked.
    - task 4 doesn't complete, because the task pool has no spaces left.
    - task 5 completes.
    - task 6 doesn't complete, because the queue 0 is locked.

    - end of processing : Scheduler unlocks both queues.

    SCHEDULER STATE :
    TASK_POOL | 2(0, 1)  3(1)  4(255) 6(0) _  _  _ |   ##  QUEUE_0 : 2 spaces left  ##  QUEUE_1 : 0 spaces left

    Then, the scheduler processes queues. Let's say, for the example, that it processes 2 task in the queue 1

    SCHEDULER STATE :
    TASK_POOL | 2(0, 1)  3(1)  4(255) 6(0) _  _  _ |   ##  QUEUE_0 : 2 spaces left  ##  QUEUE_1 : 2 spaces left

ROUND 1 :

    First, the scheduler processes the task pool :
    - task 2 can be processed, as both queues have more than one space left.

    SCHEDULER STATE :
    TASK_POOL | 3(1)  4(255) 6(0) _  _  _  _ |   ##  QUEUE_0 : 1 space left  ##  QUEUE_1 : 1 space left

    - task 3 can be executed, as queue 1 has 1 space left

    - task 4 can be executed, as 4 spaces are available in the task pool.
        -> task 7 is added

    SCHEDULER STATE :
    TASK_POOL | 6(0) 7() _  _  _  _  _ |   ##  QUEUE_0 : 1 space left  ##  QUEUE_1 : 0 space left

    - task 6 can be executed, as 1 space is left in the queue 0;

    - task 7 can be executed.


     SCHEDULER FINAL  STATE :
     TASK_POOL | _  _  _  _  _  _  _ |   ##  QUEUE_0 : 0 space left  ##  QUEUE_1 : 0 space left
     All tasks are processed on the task pool, and no spaces are left on both queues.



GOOD PRACTICES :

When you implement tasks for an interface (in [interface]Commands.cpp) :
    - If you function plans a/some type-non255 task/s, always verify that the corresponding queue does have to required
        number of spaces. If not, never forget to lock very queue related to your function.
    - Some functions plan tasks by themselves (Stepper movements plan for example). When you use them, systematically
        check the return value : if it returns "reprogram", your function must stop, eventually lock the appropriate
        queue, and return the same state.