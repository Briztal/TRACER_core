/*
  computation_network.h Part of TRACER

  Copyright (c) 2017 RaphaÃ«l Outhier

  TRACER is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  TRACER is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  aint32_t with TRACER.  If not, see <http://www.gnu.org/licenses/>.

*/

#ifndef TRACER_COMPUTATION_NETWORK_H
#define TRACER_COMPUTATION_NETWORK_H

#include <kernel/mutex/mutex.h>

#include <data_structures/containers/non_concurrent/instance.h>

#include <data_structures/containers/non_concurrent/llist.h>

#include "data_structures/containers/concurrent/dataset_host.h"


//-------------------------------------------------- Computation node --------------------------------------------------

//A computation function takes a pointer to activation data, and some input args. It returns true if complete;
typedef bool (*computation_function_t )(void *activation_data, void *input_data);


/*
 * A computation node comprises :
 * 	- A data host, that hosts the function's input data;
 * 	- A function, that can be called when the data host has initialised data;
 */

typedef struct {

	//A flag, set if the node is initialised;
	const bool initialised;

	//Computation nodes are stored in linked lists;
	linked_element_t link;

	//The node's priority
	const size_t priority;

	//Data mutex;
	mutex_t *const data_mutex;

	//The node's data host;
	dshost_t input_host;

	//The function, to call when the host has initialised data available;
	const computation_function_t function;

	//The number of output nodes;
	const size_t nb_output_nodes;

	//The array of output nodes;
	const size_t *const output_references;

} cnode_t;


/*
 * When nodes need to activate each other, they will declare their args, and call the network, providing the following
 * 	data structure (generated by the network) and an index referencing the required node to activate;
 */

typedef struct {

	//The network the node's part of;
	struct cnetwork_t *const cnetwork;

	//The node's neighbors;
	const size_t *const nodes_references;

} node_activation_t;


//------------------------------------------------- Computation network ------------------------------------------------

/*
 * A computation network is composed of an array containing a fixed number of nodes, a mutex, and a linked list
 * 	of nodes;
 */

typedef struct cnetwork_t {

	//--------------------- Constants ---------------------

	//The number of nodes in the network;
	const size_t nb_nodes;

	//The number of uninitialised nodes;
	size_t uninitialised_nodes;


	//--------------------- Nodes ---------------------

	//The mutex to protect the active nodes linked list;
	mutex_t *const list_mutex;

	//The active nodes list;
	linked_list_t active_nodes;

	//The array of nodes;
	cnode_t *const nodes;


	//--------------------- Sync ---------------------

	//The flag set when the network is dead;
	volatile bool terminated;

	//The number of concurrent executions
	volatile bool re_initialisation_required;

	//The flag that prevents double initialisation;
	volatile bool init_exit_lock;


	//--------------------- Init - Exit ---------------------

	//The data to provide at initialisation;
	void *init_data;

	//The network initialisation function;
	bool (*init)(void *data, const cnode_t *nodes);

} cnetwork_t;


//------------------------------------------------ Creation - deletion -------------------------------------------------

//Create a computation network, providing the number of nodes, a mutex to protect the active nodes list,
//The data instance, and the initialisation function;
cnetwork_t *cnetwork_create(size_t nb_nodes, mutex_t *mutex_src, instance_t *instance,
							bool (*init)(void *data, const cnode_t *nodes));


//Initialise a computation node, providing its priority, the size of its arguments, its max number of concurrent
// executions,its number of output references, and array containing them;
void cnetwork_init_node(cnetwork_t *cnetwork, size_t node_index, size_t priority,
						computation_function_t function,
						size_t arguments_size, size_t nb_concurrent_execs,
						size_t nb_outputs, const size_t *output_references_const);

//Delete a computation network and all its dynamic data;
void cnetwork_delete(cnetwork_t *cnetwork);


//----------------------------------------------------- Execution ------------------------------------------------------

//Execute an available node; Concurrency supported;
bool cnetwork_execute(cnetwork_t *cnetwork);

//Activate a node providing args; Concurrency supported;
void cnetwork_activate(cnetwork_t *cnetwork, cnode_t *node, const void *args, size_t args_size);

//Activate a node providing args; Concurrency supported;
void cnetwork_activate_neighbor(const void *activator, size_t neighbor_id, const void *args, size_t args_size);


#endif //TRACER_COMPUTATION_NETWORK_H
