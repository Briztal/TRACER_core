//
// Created by root on 9/5/18.
//


#include <stdint.h>

#include <stdbool.h>

#include <kernel/timer/timer.h>

#include <kernel/fs/dfs.h>

#include <kernel/ic.h>

#include <util/string.h>
#include <kernel/log.h>



/*
 * This file contains code for a single PIT channel. It must be compiled for each channel. 
 * 
 * 	This file takes macros parameters generated by the makefile, namely : 
 * 	- CHANNEL_ID : the identifier of the PIT, supposedly an integer between 0 and NB_CHANNELS-1
 * 	- __REGISTERS_START__ : the address of the first channel's register area;
 * 	- __REGISTERS_SPACING__ : the address space between two channels register areas;
 * 	
 * 	A PIT registers follows the map below :
 * 	
 * 	{
 * 		//The Load Value;
 * 		volatile uint32_t LDVAL;
 * 	
 * 		//Current Value;
 * 		volatile uint32_t CVAL;
 * 
 * 		//Timer Control Register
 * 		volatile uint32_t TCTRL;
 * 
 * 		//Timer Flag;
 * 		volatile uint32_t TFLG;
 * 
 *	 };
 * 
 */


//------------------------------------------------ Make parameters ------------------------------------------------
/*
 * Makefile must provide :
 * 	- CHANNEL_ID : Channel identifier;
 * 	- INT_CHANNEL : interrupt channel;
 * 	- REG : start of the channel's registers area;
 */

//If one of the macro was not provided :
#if !defined(CHANNEL_ID) || !defined(INT_CHANNEL) || !defined(REG)

//Log
#error "Error, at least one macro argument hasn't been provided. Check the makefile;"

//Define macros. Allows debugging on IDE environment;
#define CHANNEL_ID    0
#define INT_CHANNEL 0
#define REG 0

#endif


//------------------------------------------------ Internal parameters ------------------------------------------------

#define REGISTERS ((volatile uint32_t *)(REG))

#define LDVAL    ((volatile uint32_t *) (REGISTERS))
#define CVAL    ((volatile uint32_t *) (REGISTERS + 1))
#define TCTRL    ((volatile uint32_t *) (REGISTERS + 2))
#define TFLG    ((volatile uint32_t *) (REGISTERS + 3))

//Enable the timer;
#define TCTRL_TEN    ((uint32_t)(1<<0))

//Enable the interrupt;
#define TCTRL_TIE    ((uint32_t)(1<<1))

//Timer interrupt flag. W1C
#define TFLG_TIF (1<<0)


//-------------------------------------------------- Timer Operations --------------------------------------------------

/*
 * All variables and methods in this section are private. No one can access them outside this translation unit;
 */


//The ratio tics/period;
static uint32_t period_to_tics;

//The maximal period;
static uint32_t max_period;


//TODO BUS CLOCK;

static void set_base_frequency(uint32_t frequency) {
	;

	//Determine the tics/period ratio;
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);
	//TODO:::::::: uint32_t _period_to_tics = ((uint32_t) iface->clock_frequency) / ((uint32_t) frequency);

	//TODO FPU !!!!!!!!!!!!!!!!!!!!


	uint32_t _period_to_tics = ((uint32_t) 24000000) / ((uint32_t) frequency);

	//Determine the maximal period;
	uint32_t _max_period = ((uint32_t) -1) / period_to_tics;

	//Save both constants;
	period_to_tics = _period_to_tics;
	max_period = _max_period;

}


//Enable the timer;
static void start() {

	//Set TEN;
	(*TCTRL) |= TCTRL_TEN;
}


//Disable the timer;
static void stop() {

	//Clear TEN;
	*TCTRL &= ~TCTRL_TEN;
}


//Is the timer enabled ?
static bool started() {

	//Return the state of TCTRL_TEN;
	return (bool) (*TCTRL & TCTRL_TEN);

}


//Update the reload value;
static void set_count(uint32_t period_count) {

	if (period_count < max_period) {
		*CVAL = (uint32_t) (period_to_tics * period_count);
	}

}

//Get the current value;
static uint32_t get_count() {
	return (((uint32_t) *CVAL) / period_to_tics);
}


//Update the reload value;
static void set_ovf(uint32_t period_count) {

	//If the period count is invalid, use the maximal period;
	if (period_count >= max_period) {
		period_count = max_period - 1;
	}

	/*
	 * Update LDVAL, so that interrupts happen at the required period, and update CVAL, so that the next
	 * interrupt hapens in @period_count period units;
	 */
	*LDVAL = *CVAL = (uint32_t) (period_to_tics * period_count);

}

//Get the reload value;
static uint32_t get_ovf() {
	return (((uint32_t) *LDVAL) / period_to_tics);
}


//Enable the interrupt;
static void enable_int() {
	//Set bit 1 of TCTRL;
	*TCTRL |= TCTRL_TIE;

}

//Disable the interrupt;
static void disable_int() {

	//Clear bit 1 of TCTRL;
	*TCTRL &= ~TCTRL_TIE;
}

//Is the interrupt enabled ?
static bool int_enabled() {

	//Is bit 1 of TCTRL set ?
	return (bool) (*TCTRL & TCTRL_TIE);

}


//Is the flag set ?
static bool flag_is_set() {
	//Is bit 0 of TFLG set ?
	return (bool) (*TFLG);
}


//Clear the interrupt flag;
static void flag_clr() {
	//Set bit 0 of TFLG;
	*TFLG = 1;
}


//The client handler. Can be modified, and null;
static void (*client_handler)();

/**
 * The channel handler. Clears the interrupt flag, and calls the client handler if not null;
 */

static void handler() {

	//Clear the flag, to prevent more interrupt requests;
	flag_clr();

	//Cache the custom handler;
	void (*hdlr)() = client_handler;

	//If the custom handler is not null, execute it;
	if (hdlr) (*hdlr)();

}


//Update the handler;
static void set_handler(void (*handler)()) {

	//Update the client handler;
	client_handler = handler;

}


//---------------------------------------------------- Hidden code -----------------------------------------------------

/*
 * All variables and methods in this section are hidden. No one can access them outside the PIT library;
 */

/*
 * This file is compiled once for each instance of the timer channel. Its non-static symbols can't have the same name;
 *
 * 	When referring one of its public symbols, the macro NM will be used. It takes the generic name, and concatenates
 * 	the instance index, so that all channels have different methods;
 */



#define _CAT(a, b, c) a##b##c

#define CAT(a, b, c)  _CAT(a, b, c)

#define NM(name) CAT(name,_,CHANNEL_ID)


/*
 * The timer interface;
 */

const struct timer_interface NM(kx_pit_channel) __attribute__((visibility("hidden"))) = {

	.set_base_frequency = &set_base_frequency,

	.start = &start,
	.stop = &stop,
	.started = &started,

	.set_count = &set_count,
	.get_count = &get_count,

	.set_ovf_value = &set_ovf,
	.get_ovf_value = &get_ovf,

	.enable_int = &enable_int,
	.disable_int = &disable_int,
	.int_enabled = &int_enabled,

	.flag_is_set = &flag_is_set,
	.flag_clr = &flag_clr,

	.set_handler = &set_handler,

};

//The interface will be copied, and neutralised when
static void *timer_if_copy = 0;


//Two macros to determine the string name;
#define _ST(x) #x
#define ST(x) _ST(x)
#define PNM "pit_" ST(CHANNEL_ID)

//Create the name;
static const char *const pit_name = PNM;


//Transmit the timer interface;
static bool channel_interface(void *data, size_t data_size) {

	//If the channel is already interfaced :
	if (timer_if_copy) {

		//Fail, only one interface is made at the time;
		return false;

	}

	//If the data size doesn't match a timer interface :
	if (data_size != sizeof(struct timer_interface)) {

		//Fail;
		return false;

	}

	//Transmit a copy of the interface;
	memcpy(data, &NM(kx_pit_channel), sizeof(struct timer_interface));

	//Save the reference of the copy for future neutralisation;
	timer_if_copy = data;

	//Complete;
	return true;

}

//Close the timer resource : will neutralise the interface;
static void channel_close() {

	//If the timer is already interfaced :
	if (timer_if_copy) {

		//Neutralise the timer interface;
		memcpy(timer_if_copy, &neutral_timer_interface, sizeof(struct timer_interface));

	}

}


/*
 * The file operations for a pit channel are limited to interface, and close that neutralises the interface;
 */

static struct dfs_file_operations file_operations = {
	.close = &channel_close,
	.interface = &channel_interface,
};


/**
 * 	kx_pit_channel_init_i : initialises the channel; Called by the pit module's init function
 */

void NM(kx_pit_channel_init)() {

	//Register a file with no content leading to our operations;
	dfs_create(pit_name, DFS_INTERFACE, &file_operations, 0);

	//Reset the timer, and set the base frequency to 1KHz
	timer_reset(&NM(kx_pit_channel), 1000);

	//Register the pit handler;
	ic_set_interrupt_handler(INT_CHANNEL, &handler);

	//Set the channel int priority;
	ic_set_interrupt_priority(INT_CHANNEL, KERNEL_DRIVER_STATUS_PRIORITY);

	//Enable the channel interrupt;
	ic_enable_interrupt(INT_CHANNEL);

}


/**
 * 	kx_pit_channel_exit_i : initialises the channel; Called by the pit module's init function
 */

bool NM(kx_pit_channel_exit)() {

	//Attempt to remove the file;
	if (dfs_remove(pit_name)) {

		//Reset the timer, and set the base frequency to 1KHz
		timer_reset(&NM(kx_pit_channel), 1000);

		//Unregister the pit handler;
		ic_set_interrupt_handler(INT_CHANNEL, 0);

		//Disable the channel interrupt;
		ic_disable_interrupt(INT_CHANNEL);

		//Complete;
		return true;

	}

	//If removal failed, fail;
	return false;

}


#undef NM

//-------------------------------------------------- File Operations --------------------------------------------------


/*
 * All variables and methods in this section are private. No one can access them outside this translation unit;
 */

